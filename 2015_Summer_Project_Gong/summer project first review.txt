Project overview

1. read in the data (R)
    - standadized version?
    - each row corresponding to data at n shifts(x coordinate) with K laser excitation(k = 0, 1,...k)   (in this case, K = 2)
    - three rows

    - for each k, n may differ in this project
    - cut off?    
    - ***********problem: how to convert the data into a K*N matrix


<<<<<<<<<<<<<<<<<<<<<<<<<<
2. implementation

Method 1: 
    R = TL(Tranpose)
    - decompose
    - the first row in L(Tranpose) = S(R) (expected ramen signal)(pseudo-derivative Ramen specturm)
    - other row in L(Tranpose) will discribe the fluorescence and other random noise
    
    - difficult/impossible
    

Method 2:
    HS = R
    - S = what we want / expected result
        S = (S(F)   S(R))       (seperated fluorescence and raman signal)
             1*N     1*N        
    - Sizeof(S) = 1*2N
    
    
    - R rewritten  ->      R0, R1....Rk  
    - Sizeof(R) = 1*kN   (R0 = 1*N)
    
    
    - H = operator matrix  
    (N*N)   submatrix at each entry,      
    sizeofH = 2*N * k*N
    - each submatrix describes the spectral position of fluorescence intensity at k excitation
    - characteristic: 
            1. sparse matrix 
                each row, only one entry is 1. other = 0
                the whole submatrix must be an identity matrix 
                - because when k changes, fluorescence intensity will not shift(change) 
            
    So up to now, 
    - target:    given H and R, solve for S
        - impossible(because H is sparse)
    - method: using Lucy-Richardson formula to iteratively solve
        - basic idea: 
            1. given the initial estimate of S(R) and s(F)  (each of this has size                  of 1*N) 
                - S(R) at each N = select the maximum spectral intensity from each                      k. 
                - That is    S(R) at 0 = max value in k spectrums at n=0 (a number)
                - S(R) = n numbers...
                
                similarly, S(F) = n numbers...represent the min values at each                      index n
                
            2. do the iteration
                equation8
                - for each position n, S(R)/S(F) at i=0 is known, can get S(R)/S(F)                 at i = 1...then i = 1000/2000
                - at this position n, S(R) eventually converges. That is the                       expected value S(R)/S(F)
                
                -for n positions, do iteration...
                
    - too slow
    
    


Method 3:
    - this is what this paper is talking about..
    - why we can simplify method 2 like this:
        identity matrix 
        also the first submatrix in the second column (k = 0, raw data)(without laser change) is also a identity matrix
            - else if excitation change, 其他地方会有ramen signal的叠加，每一个row里面不只有一个地方是1 (other entry may be nonzero)
    
    - simplified version of iteration
        - equation 9-11
        
        - element wise(add/divide seperatly for each element)
        
        - S(F) at 0,n    is known (different for each n)
        - S(R) at i,n-K   (i = 0, k=0 is known)   
            eg: if we are calculating the S(F)/S(R) at position 0
            s(f) at 0, 0 is known
            s(r) at i=0, n-k    (when k=0) is known
                - ************** problem:
                    k = 2, n = 0, S(r) at i=0, n-k ????? data doesn't exist?
                    
        W0 is known(using k excitations) at this n 
            - not sure about this, but this equation has a fix value for n?
            
        - for each i, n Wi is a number
        - for each i, there are n Wi    
			*******************problem:
				Wi is a weighting vector?? 
				
				
				***
				Wi cross product with sF (only defined in dim3/7)
				
        - S(F) at this i is known (base case, is the row data i=0, 1*N)
        
        - sum up
            - for each i, n Wi  (1*N )
            - for each i, S(F)    is also a (1*N) matrix
            - result from matrix multiplication 
                - S(F) at i+1   is also a (1*N) matrix
            
            similar for S(R)
            
            - iteratate from i = 0, .... eventually S(F)/S(R) converges
            - this is the result
            
            - so for each iteration i, n*k operation time (n slots/k times to calculate wi at some n)
            
            
            

<<<<<<<<<<<<<<<<<<
3. limitations
    1. fixed change in excitation shift between the utilized excitations
        - const wavelentgh spacing
        
        
<<<<<<<<<<<<<<<<<<
4. discussion
    1. ********problem:
    use the standard deviation spectrum of the raw spectra as the initial estimate of S(R) (1*n matrix) - more reliable than max at each n
    2. converge usually at i = 2000
    3. -currently developing a convergence detection algorithm
        - so far we need a fixed i max = 2000/3000 (larger i does no harm)
    
    ********problem:
        - perform standard normal variance normalization before SSE?
        - row data
    perform stand
        
